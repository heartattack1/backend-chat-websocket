# План улучшений на основе assessment.md

Ниже — список задач с кратким описанием **как выполнять**. Приоритизация основана на рисках безопасности, надежности и масштабируемости.

## P0 (критично/важно)

### 1. Добавить аутентификацию/авторизацию (OAuth2, отечественная соцсеть)
**Цель:** защитить идентичность пользователя и исключить подмену ника.

**Как делать:**
- Выбрать провайдера (VK ID/ЕСИА) и зарегистрировать OAuth2 приложение.
- Включить `spring-boot-starter-oauth2-client` и настроить `application.yml` с client-id/secret.
- После успешного OAuth-логина маппить пользователя на `Principal`, а ник брать из профиля провайдера.
- Обновить `UsernameResolver` и WebSocket handshake: если есть `Principal`, игнорировать заголовки `username`/`author`.
- Добавить минимальную страницу login/redirect (или использовать стандартную Spring Security страницу).

**Definition of Done (DoD):**
- Пользователь без OAuth2 не может войти в чат.
- Ник формируется из доверенных данных провайдера.
- В UI убрать ввод ника, отображать имя из профиля.

---

### 2. Ограничить `AllowedOriginPatterns` для WebSocket
**Цель:** закрыть доступ посторонним доменам.

**Как делать:**
- Заменить `setAllowedOriginPatterns("*")` на список разрешенных доменов, например через `application.yml`.
- Добавить config property (например `chat.websocket.allowed-origins`) и применять ее в `WebSocketConfig`.
- Для локальной разработки оставить `http://localhost:8080`.

**DoD:**
- Подключение с неразрешенных доменов блокируется.
- Список разрешенных доменов конфигурируется через env/props.

---

### 3. Обработка ошибок WebSocket-сообщений
**Цель:** информировать клиента о проблемах отправки (валидация, лимиты, пустой текст).

**Как делать:**
- Добавить `@MessageExceptionHandler` в `ChatWebSocketController` или отдельный advice.
- Отправлять ошибки в `/queue/errors` с понятным JSON-пейлоадом.
- В UI подписаться на `/user/queue/errors` и показывать toast/alert.

**DoD:**
- При пустом/слишком длинном сообщении клиент получает информативную ошибку.
- Ошибки отображаются в UI.

---

## P1 (масштабирование и надежность)

### 4. Внешний брокер для STOMP и shared presence
**Цель:** корректная работа в multi-instance.

**Как делать:**
- Подключить RabbitMQ/Redis broker и заменить `enableSimpleBroker` на broker relay.
- Вынести presence registry в Redis (например, `SET` + TTL на sessionId).
- Реализовать обновление списка пользователей с учетом TTL и cleanup.

**DoD:**
- Два инстанса приложения видят единый список онлайна.
- Сообщения распространяются между инстансами без потери.

---

### 5. Индексы и ретеншн истории
**Цель:** ускорение выборки `last N` и контроль объема.

**Как делать:**
- Добавить индекс по `created_at` (и, при необходимости, `id`) через Liquibase миграцию.
- Опционально: периодический job для удаления старых сообщений (TTL) или архивирования.

**DoD:**
- Запрос `last N` использует индекс (проверить план запроса).
- Политики хранения описаны в README.

---

### 6. Rate limiting и защита от спама
**Цель:** защитить сервер от флуд-атак.

**Как делать:**
- Ввести ограничение на частоту сообщений на пользователя (например, 5–10 msg/sec).
- Реализовать in-memory лимитер (bucket/token) на первое время; при multi-instance — Redis.
- Возвращать клиенту ошибку и информировать в UI.

**DoD:**
- Ограничение фиксируется в логах и отражается в UI.

---

## P2 (UX/продукт)

### 7. Пагинация/ленивая загрузка истории
**Цель:** доступ к более старым сообщениям без перегруза.

**Как делать:**
- Добавить параметр `before` (timestamp/id) в `GET /api/chat/history`.
- На UI реализовать кнопку "Загрузить ещё" или загрузку при скролле вверх.

**DoD:**
- Пользователь может подгружать историю пачками.

---

### 8. Подтверждение доставки и статусы
**Цель:** повысить доверие к отправке сообщений.

**Как делать:**
- Возвращать ack-сообщение на персональную очередь `/user/queue/acks`.
- В UI показывать статус (отправлено/доставлено/ошибка).

**DoD:**
- Сообщение получает статус и обновляется при ack.

---

### 9. Документация сборки без Docker
**Цель:** полный набор инструкций.

**Как делать:**
- В README добавить `./gradlew build` и локальный запуск с переменными БД.
- Описать профили/переменные окружения и порядок запуска.

**DoD:**
- Разработчик может запустить проект без Docker по README.

---

## Рекомендуемый порядок внедрения
1. P0 задачи: безопасность, CORS/Origins, обработка ошибок.
2. P1 задачи: масштабирование, индексы, rate limiting.
3. P2 задачи: UX и документация.

