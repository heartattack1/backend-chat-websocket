# Project plan: Backend Chat WebSocket

## 1. Требования из ТЗ (классификация)

### MUST (обязательные)
- Один общий чат.
- Ввод ника перед входом в чат.
- Пользователь видит последние **N** сообщений сразу после входа.
- Новые сообщения доставляются всем подключенным пользователям мгновенно (без refresh).
- Список пользователей онлайн.
- История чата хранится в БД.
- Java + сервер приложений (Spring Boot допустим).
- Исходники + собранный артефакт; минимальные инструкции по сборке/запуску/использованию.
- Не использовать готовые движки веб-чатов.

### SHOULD / NICE-TO-HAVE (плюсы)
- Docker-образ.
- Максимально использовать сторонние библиотеки (open-source).
- Авторизация через отечественную соцсеть.
- Hibernate/JPA для БД.
- Доставка обновлений без постоянного refresh (WebSocket/SSE/long-poll и т.п.).

### Нефункциональные требования
- Сборка и запуск должны быть воспроизводимы.
- Описание как собрать, запускать и пользоваться.

---

## 2. Текущее состояние репозитория (кратко)

- **Стек:** Spring Boot + WebSocket/STOMP + SockJS, Spring Data JPA, Liquibase, PostgreSQL.
- **WebSocket:** есть endpoint `/ws`, STOMP broker `/topic` и `/queue`, приложения на `/app`.
- **Домен:** `ChatMessage`, `MessageId`, `UserId`, сценарии для отправки сообщений.
- **Persistence:** JPA-сущности и репозитории для сообщений и пользователей; миграции Liquibase.
- **REST:** есть только ping-эндпоинт в OpenAPI.
- **Docker:** присутствуют `Dockerfile` и `docker-compose.yml`.
- **UI:** создана папка `frontend` под перенос UI; исходники `ui-chat-stopm` ещё не перенесены из‑за сетевых ограничений доступа к GitHub.

### Что уже реализовано (подтверждающие пути)
- WebSocket конфигурация: `src/main/java/.../adapters/inbound/websocket/WebSocketConfig.java`.
- WebSocket controller: `src/main/java/.../adapters/inbound/websocket/ChatWebSocketController.java`.
- Сценарий отправки в чат (без сохранения в БД): `src/main/java/.../application/scenario/PostChatMessageScenario.java`.
- Сценарий сохранения сообщений: `src/main/java/.../application/scenario/PostMessageScenario.java`.
- Репозиторий истории (last N): `src/main/java/.../domain/repository/ChatMessageRepository.java`, `src/main/java/.../adapters/outbound/persistence/JpaChatMessageRepositoryAdapter.java`.
- Liquibase миграции БД: `src/main/resources/db/changelog/**`.
- Docker артефакты: `Dockerfile`, `docker-compose.yml`.
- Текущее описание: `README.md`.

### Зазоры/недостающие компоненты
- UI (страница ввода ника, чат-окно, список онлайн).
- Получение истории (last N) на входе.
- Персистенция сообщений из WebSocket-флоу (сейчас WebSocket-сценарий не сохраняет).
- Presence/список онлайн пользователей.
- Полноценное руководство пользователя и сборки (есть каркас в README, но нет описания UX чат-флоу).
- Соц. авторизация (опционально).

---

## 3. Таблица соответствия ТЗ → статус

| Требование | Статус | Доказательство (пути) | Комментарий |
|---|---|---|---|
| Один общий чат | Partial | `ChatWebSocketController`, `WebSocketConfig` | Канал есть, UI нет. |
| Ввод ника перед входом | Not started | — | Требуется UI и/или handshake logic. |
| Последние N сообщений на входе | Partial | `ChatMessageRepository#findLastN`, JPA adapter | Нет API/WS флоу выдачи истории. |
| Мгновенная доставка сообщений без refresh | Done | `WebSocketConfig`, `ChatWebSocketController` | WebSocket/STOMP работает. |
| Список пользователей онлайн | Not started | — | Есть только логирование connect/disconnect. |
| История чата в БД | Partial | Liquibase + JPA repositories | WebSocket сообщения не сохраняются. |
| Java + сервер | Done | Spring Boot project structure | Ок. |
| Исходники + артефакт + инструкции | Partial | `README.md`, `Dockerfile`, `docker-compose.yml` | Нужны инструкции по использованию. |
| Не использовать готовые webchat движки | Done | — | В проекте не обнаружено. |
| Docker образ | Done | `Dockerfile`, `docker-compose.yml` | Уже есть. |
| Hibernate/JPA | Done | JPA репозитории/сущности | Уже есть. |
| Соц. авторизация (отечественная) | Not started | — | Опционально. |

---

## 4. План работ (только оставшиеся части)

> Формат: **Epic → Task → Subtasks**. Каждая подзадача самостоятельна.

### Epic A. История чата и единый жизненный цикл сообщений

**Цель:** любое сообщение, отправленное через WebSocket, сохраняется в БД и доступно для выдачи последних N сообщений при входе.

#### Task A1. Интеграция WebSocket-сценария с сохранением сообщений
- **Подзадача A1.1**: Привязать `PostChatMessageScenario` к доменному `PostMessageScenario` или вынести единый сервис.
  - **DoD:** при отправке через `/app/chat.send` сообщение сохраняется в таблице сообщений.
  - **Затронутые модули:** `application/scenario/PostChatMessageScenario`, `application/scenario/PostMessageScenario`, `domain/repository/ChatMessageRepository`.
  - **Подход:** объединение сценариев или последовательный вызов (логика в одном месте).
  - **Риски/вопросы:** требуется определить единый формат id (UUID vs ULID).

- **Подзадача A1.2**: Согласовать модель события и доменной сущности.
  - **DoD:** ID/createdAt единообразны в event и domain model.
  - **Затронутые модули:** `application/event/ChatMessageEvent`, `domain/model/ChatMessage`.
  - **Подход:** использовать генератор ID домена и `Clock`.
  - **Риски/вопросы:** влияние на фронтенд формат сообщений.

#### Task A2. Получение последних N сообщений при входе
- **Подзадача A2.1**: Ввести WS-команду или REST-эндпоинт для получения истории.
  - **DoD:** клиент на входе получает последние N сообщений из БД.
  - **Затронутые модули:** `adapters/inbound/websocket`, `application/scenario`, `domain/repository`.
  - **Подход:** `@MessageMapping("/chat.history")` или REST `/api/chat/history?limit=N`.
  - **Риски/вопросы:** согласование формата payload и сортировки (по времени ASC).

- **Подзадача A2.2**: Пагинация/лимитирование и дефолтный N.
  - **DoD:** лимит на запрос истории + безопасное значение по умолчанию.
  - **Затронутые модули:** `domain/repository/ChatMessageRepository`, `JpaChatMessageRepositoryAdapter`.
  - **Подход:** использовать `findLastN`, добавить контролируемые лимиты.

---

### Epic B. Presence и список онлайн пользователей

**Цель:** отображение списка онлайн-пользователей для всех клиентов.

#### Task B1. Учёт подключений/отключений
- **Подзадача B1.1**: Реализовать in-memory реестр активных пользователей (ConcurrentMap).
  - **DoD:** при connect/disconnect список обновляется.
  - **Затронутые модули:** `WebSocketSessionEventListener`, новый сервис presence.
  - **Подход:** хранить `sessionId -> username`.
  - **Риски/вопросы:** определение username (из handshake или header).

- **Подзадача B1.2**: Опубликовывать события списка онлайн в `/topic/chat.users`.
  - **DoD:** все клиенты получают актуальный список при изменениях.
  - **Затронутые модули:** `ChatBroadcaster` или отдельный broadcaster.
  - **Подход:** broadcast списка при connect/disconnect.

#### Task B2. Определение никнейма пользователя
- **Подзадача B2.1**: Определить протокол передачи ника (header, initial message, query param).
  - **DoD:** имя пользователя стабильно доступно серверу.
  - **Затронутые модули:** `ChatWebSocketController`, `WebSocketConfig`, presence-сервис.
  - **Подход:** использовать STOMP headers `author` или `/app/chat.join`.
  - **Риски/вопросы:** защита от пустых/дубликатов имен.

---

### Epic C. UI/Frontend (страница чата)

**Цель:** минимальный клиентский интерфейс без готовых движков.

#### Task C0. Импорт и разбор UI из `ui-chat-stopm`
- **Подзадача C0.1**: Склонировать `https://github.com/heartattack1/ui-chat-stopm` в `frontend/`.
  - **DoD:** исходники UI доступны локально, без вложенного `.git` (или оформлены как submodule по решению команды).
  - **Риски/вопросы:** возможные ограничения сети; при отсутствии доступа к GitHub — использовать зеркала или перенос архивом.
- **Подзадача C0.2**: Проанализировать структуру фронтенда и зависимости.
  - **DoD:** зафиксирован стек (framework/bundler), точки входа, сборка, конфигурация.
  - **Затронутые модули:** `frontend/**`, будущая документация.
- **Подзадача C0.3**: Подготовить план интеграции с backend WS/STOMP контрактами.
  - **DoD:** список соответствий между UI событиями и backend endpoints (`/ws`, `/app/**`, `/topic/**`).
  - **Риски/вопросы:** различия в формате payload и именах топиков.

#### Task C1. Страница ввода ника и подключение к WebSocket
- **Подзадача C1.1**: HTML/CSS/JS страница с формой ввода ника.
  - **DoD:** пользователь вводит ник и подключается к чату.
  - **Затронутые модули:** `frontend/**` (приоритет) или `src/main/resources/static/**` (fallback).
  - **Подход:** использовать готовый UI из `ui-chat-stopm` и адаптировать под backend контракты.

- **Подзадача C1.2**: Инициализация WS/STOMP клиента.
  - **DoD:** после подключения подписки на `/topic/chat.messages` и `/topic/chat.users`.
  - **Риски/вопросы:** необходимость SockJS клиента.

#### Task C2. Отображение истории и новых сообщений
- **Подзадача C2.1**: Получать history и показывать в хронологическом порядке.
  - **DoD:** последние N сообщений отображаются сразу.
  - **Подход:** отдельная WS-команда или REST-запрос на историю.

- **Подзадача C2.2**: Отправка сообщений и мгновенное отображение.
  - **DoD:** сообщение появляется у всех подключенных клиентов.

#### Task C3. Список онлайн пользователей
- **Подзадача C3.1**: UI-виджет списка пользователей.
  - **DoD:** список обновляется при connect/disconnect.

---

### Epic D. Документация (минимальные инструкции)

**Цель:** понятные инструкции для сборки/запуска/использования.

#### Task D1. README секции
- **DoD:** описано как собрать, как запускать, как пользоваться (включая N сообщений, вход по нику).
- **Затронутые модули:** `README.md`.
- **Подход:** краткий step-by-step + параметры конфигурации.

---

## 5. Архитектурные решения (предлагаемые)

1. **Транспорт обновлений:** WebSocket + STOMP (уже есть). Альтернатива SSE не требуется.
2. **Модель данных:** `ChatMessage(id, authorUserId/authorName, text, createdAt)`.
3. **История сообщений:** запрос `last N` из БД, сортировка ASC для отображения.
4. **Presence:** in-memory реестр online пользователей, обновляемый по событиям connect/disconnect.
5. **Пагинация:** ограниченный лимит `N` (например, 50/100 по умолчанию).
6. **Конкурентность/транзакции:** сохранение сообщений через JPA, транзакция на запись.
7. **Идентификаторы:** единая стратегия ID (ULID или UUID) для домена и сообщений события.

---

## 6. Инструкции по сборке/запуску/использованию (скелет)

> Ниже — шаблон, который нужно заполнить/проверить по факту реализации.

- **Сборка:** команды Gradle/Maven, требования Java.
- **Запуск локально:** параметры БД, порты, env vars.
- **Запуск через Docker:** `docker compose up --build`.
- **Использование:** открыть страницу чата, ввести ник, отправить сообщение, увидеть online list, получить историю последних N сообщений.

---

## 7. Опциональные улучшения (плюсы)

- **Docker-образ:** уже есть, актуализировать инструкции.
- **Hibernate/JPA:** уже используется; расширить по необходимости.
- **Соц. авторизация (отечественная):**
  - Варианты: VK ID, Gosuslugi/ЕСИА (при наличии SDK/доступов), Яндекс ID (не отечественная соцсеть, но провайдер).
  - Оценить реализацию через OAuth2 client.
- **Больше open-source библиотек:** STOMP клиент, UI-библиотека для минимального интерфейса.

---

## 8. Вопросы/риски

- Нужен ли REST-API для истории, или исключительно WS?
- Какой N по умолчанию?
- Требуется ли персистить никнейм в таблицу пользователей или достаточно transient presence?
- Какая соцсеть предпочтительна для авторизации?
